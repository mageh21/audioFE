<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
    <title>MusicXML Player Demo</title>
    <style>
      :root {
        --primary-color: #4a90e2;
        --secondary-color: #f8f9fa;
        --text-color: #2c3e50;
        --border-radius: 8px;
      }

      body {
        background-color: var(--secondary-color);
        font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        margin: 0;
        padding: 20px;
        color: var(--text-color);
      }

      .hide {
        display: none;
      }

      h1 {
        text-align: center;
        color: var(--primary-color);
        margin-bottom: 30px;
        font-size: 2.5em;
      }

      .main-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      .controls-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .upload-section {
        background: white;
        padding: 20px;
        border-radius: var(--border-radius);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
      }

      .upload-section:hover {
        transform: translateY(-2px);
      }

      .upload-section h3 {
        margin: 0 0 15px 0;
        color: var(--primary-color);
        font-size: 1.2em;
      }

      input[type="file"] {
        width: 100%;
        padding: 10px;
        border: 2px dashed #ddd;
        border-radius: var(--border-radius);
        margin-bottom: 10px;
        cursor: pointer;
      }

      input[type="file"]:hover {
        border-color: var(--primary-color);
      }

      select {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        background: white;
        cursor: pointer;
      }

      #sheet-container {
        height: calc(100vh - 300px);
        margin: 20px 0;
        border-radius: var(--border-radius);
        background: white;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow-y: auto;
        padding: 20px;
        margin-bottom: 100px;
      }

      .player-controls {
        display: flex;
        align-items: center;
        gap: 20px;
        background: white;
        padding: 15px 30px;
        border-radius: var(--border-radius);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        flex-wrap: wrap;
      }

      .controls-group {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .playback-controls {
        display: flex;
        align-items: center;
        gap: 30px;
        flex-wrap: wrap;
      }

      .slider-control {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 200px;
      }

      .slider-control label {
        font-size: 14px;
        color: var(--text-color);
        min-width: 120px;
      }

      .slider-control input[type="range"] {
        flex: 1;
        height: 6px;
        -webkit-appearance: none;
        background: #ddd;
        border-radius: 3px;
        outline: none;
      }

      .slider-control input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        background: var(--primary-color);
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s;
      }

      .slider-control input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.1);
      }

      .slider-control .value {
        min-width: 60px;
        font-size: 14px;
        color: var(--text-color);
        text-align: right;
      }

      .player {
        font-size: 22px;
        width: 44px;
        height: 44px;
        border: none;
        border-radius: 50%;
        background: var(--primary-color);
        color: white;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        line-height: 1;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .player:hover {
        transform: scale(1.05);
        background: #357abd;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .player:active {
        transform: scale(0.95);
      }

      .player:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .player#playPause { 
        width: 52px;
        height: 52px;
        font-size: 24px;
      }

      .player#playPause[title="Stop"] {
        background-color: #e74c3c;
      }

      .player#playPause[title="Stop"]:hover {
        background-color: #c0392b;
      }

      .instrument-selector {
        min-width: 220px;
        padding: 10px 15px;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        font-size: 14px;
        color: var(--text-color);
        background: white;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .instrument-selector:hover {
        border-color: var(--primary-color);
      }

      .instrument-selector:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
      }

      #player {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background: rgba(255, 255, 255, 0.95);
        padding: 15px;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        z-index: 1000;
        display: flex;
        justify-content: center;
      }

      #play {
        padding-left: 3px;
      }

      #pause {
        font-size: 18px;
      }

      #rewind {
        font-size: 16px;
      }

      #feedback, #pdf-feedback {
        margin-top: 10px;
        padding: 10px;
        border-radius: var(--border-radius);
        font-size: 0.9em;
      }

      .success { 
        color: #2ecc71;
        background: #e8f8f5;
      }

      .error { 
        color: #e74c3c;
        background: #fdedec;
      }

      .loading { 
        color: var(--primary-color);
        background: #eef7ff;
      }

      .spinner {
        border: 3px solid rgba(74, 144, 226, 0.1);
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border-left-color: var(--primary-color);
        animation: spin 1s linear infinite;
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      button {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: var(--border-radius);
        cursor: pointer;
        transition: background 0.2s;
      }

      button:hover {
        background: #357abd;
      }

      .player-loading {
        position: relative;
      }

      .player-loading::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 16px;
        height: 16px;
        margin: -8px 0 0 -8px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s linear infinite;
      }

      .player-loading.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    </style>
    <link rel="stylesheet" href="build/musicxml-player.css">
  </head>
  <body>
    <div class="main-container">
      <h1>MusicXML Player</h1>

      <div class="controls-grid">
        <div class="upload-section">
          <h3>Upload MusicXML File</h3>
          <input type="file" id="file-input" accept=".musicxml,.mxl,.xml"/>
          <div id="feedback"></div>
        </div>

        <div class="upload-section">
          <h3>Upload PDF Score</h3>
          <input type="file" id="pdf-input" accept=".pdf,image/*"/>
          <button id="convert-basic-btn">Convert to MusicXML</button>
          <div id="pdf-feedback"></div>
        </div>

        <div class="upload-section">
          <h3>Sample Scores</h3>
          <select id="samples">
            <option value="">-- Choose a sample --</option>
            <option value="data/asa-branca.musicxml">Asa Branca</option>
            <option value="data/bach-invention-1.musicxml">Bach Invention No. 1</option>
            <option value="data/chopin-prelude-20.musicxml">Chopin Prelude No. 20</option>
            <option value="data/debussy-clair-de-lune.musicxml">Debussy Clair de Lune</option>
          </select>
        </div>
      </div>

      <div id="sheet-container"></div>

      <div id="player">
        <div class="player-controls">
          <div class="playback-controls">
            <div class="controls-group">
              <button class="player" id="rewind" title="Rewind">⏮</button>
              <button class="player" id="play" title="Play">▶</button>
              <button class="player" id="pause" title="Pause">⏸</button>
            </div>
            <div class="slider-control">
              <label>Tempo (BPM)</label>
              <input type="range" id="tempoControl" min="40" max="208" value="120" step="1">
              <span class="value" id="tempoValue">120</span>
            </div>
            <div class="slider-control">
              <label>Transpose (semitones)</label>
              <input type="range" id="pitchControl" min="-12" max="12" value="0" step="1">
              <span class="value" id="pitchValue">0</span>
            </div>
            <div class="slider-control">
              <label>Pitch (Hz)</label>
              <input type="range" id="frequencyControl" min="380" max="480" value="440" step="1">
              <span class="value" id="frequencyValue">440</span>
            </div>
          </div>
          <select id="instrumentSelector" class="instrument-selector">
            <option value="">Select Instrument...</option>
            <optgroup label="Piano">
              <option value="0">Acoustic Grand Piano</option>
              <option value="1">Bright Acoustic Piano</option>
              <option value="4">Electric Piano</option>
              <option value="6">Harpsichord</option>
            </optgroup>
            <optgroup label="Percussion">
              <option value="11">Vibraphone</option>
              <option value="12">Marimba</option>
              <option value="13">Xylophone</option>
            </optgroup>
            <optgroup label="Strings">
              <option value="40">Violin</option>
              <option value="41">Viola</option>
              <option value="42">Cello</option>
              <option value="43">Contrabass</option>
            </optgroup>
            <optgroup label="Brass">
              <option value="56">Trumpet</option>
              <option value="57">Trombone</option>
              <option value="58">Tuba</option>
            </optgroup>
            <optgroup label="Woodwinds">
              <option value="68">Oboe</option>
              <option value="71">Clarinet</option>
              <option value="73">Flute</option>
              <option value="70">Bassoon</option>
            </optgroup>
            <optgroup label="Guitar">
              <option value="24">Acoustic Guitar (Nylon)</option>
              <option value="25">Acoustic Guitar (Steel)</option>
              <option value="26">Electric Guitar (Jazz)</option>
            </optgroup>
          </select>
        </div>
      </div>
    </div>

    <script type="module">
      import {
        Player,
        VerovioConverter,
        VerovioRenderer,
        SoundFontOutput
      } from './build/musicxml-player.mjs';

      let currentPlayer = null;
      let currentMusicXml = null;
      let currentOutput = null;
      let isProcessing = false;
      let isLoadingSoundFont = false;
      let audioContext = null;
      let soundFontLoaded = false;
      let currentInstrumentId = null;
      let playbackInterval = null;  // Add interval tracking
      let currentPitchSettings = {
        semitones: 0,
        frequency: 440
      };

      // Get button elements (do this once)
      const playBtn = document.getElementById('play');
      const pauseBtn = document.getElementById('pause');
      const rewindBtn = document.getElementById('rewind');

      // Function to show loading state on a button
      function setButtonLoading(button, isLoading) {
        if (isLoading) {
          button.classList.add('player-loading');
        } else {
          button.classList.remove('player-loading');
        }
      }

      // Function to check if pitch settings have changed
      function havePitchSettingsChanged(newSemitones, newFrequency) {
        return currentPitchSettings.semitones !== newSemitones || 
               currentPitchSettings.frequency !== newFrequency;
      }

      // Function to initialize or reinitialize SoundFont
      async function initializeSoundFont(instrumentId, force = false) {
        if (!force && soundFontLoaded && instrumentId === currentInstrumentId) {
          console.log('[initializeSoundFont] SoundFont already loaded for instrument:', instrumentId);
          return;
        }

        isLoadingSoundFont = true;
        try {
          console.log('[initializeSoundFont] Initializing SoundFont for instrument:', instrumentId);
          const midiJson = {
            division: 480,
            tracks: [[{
              channel: 0,
              programChange: {
                programNumber: parseInt(instrumentId)
              }
            }]]
          };

          if (currentOutput) {
            try {
              if (typeof currentOutput.destroy === 'function') {
                await currentOutput.destroy();
              }
            } catch (e) {
              console.warn('Error cleaning up previous output:', e);
            }
          }

          currentOutput = new SoundFontOutput(midiJson);
          await currentOutput.initialize();
          soundFontLoaded = true;
          currentInstrumentId = instrumentId;
          console.log('[initializeSoundFont] SoundFont initialized successfully');
        } catch (e) {
          console.error('Error initializing SoundFont:', e);
          currentOutput = null;
          soundFontLoaded = false;
          currentInstrumentId = null;
          throw e;
        } finally {
          isLoadingSoundFont = false;
        }
      }

      // Function to clear any existing intervals
      function clearPlaybackInterval() {
        if (playbackInterval) {
          clearInterval(playbackInterval);
          playbackInterval = null;
          console.log('[clearPlaybackInterval] Cleared existing interval');
        }
      }

      // Function to handle playing music
      async function playMusic() {
        console.log('[playMusic] Called. Current state:', currentPlayer?.state);
        if (!currentPlayer || (isProcessing && !isLoadingSoundFont)) {
          console.log('[playMusic] Aborted (no player or processing).');
          return;
        }

        try {
          // Set button states before playing
          playBtn.disabled = true;
          pauseBtn.disabled = false;
          rewindBtn.disabled = false;
          console.log('[playMusic] Setting button state: Play disabled, Pause enabled, Rewind enabled');

          // Initialize audio context if needed
          if (!audioContext) {
            isProcessing = true;
            setButtonLoading(playBtn, true);
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            await audioContext.resume();
            isProcessing = false;
            setButtonLoading(playBtn, false);
          }

          // Initialize SoundFont only if not loaded
          if (!soundFontLoaded && currentInstrumentId !== null) {
            isProcessing = true;
            setButtonLoading(playBtn, true);
            await initializeSoundFont(currentInstrumentId);
            isProcessing = false;
            setButtonLoading(playBtn, false);
          }

          // Clear any existing intervals before starting playback
          clearPlaybackInterval();

          // Resume from current position if paused, otherwise start from beginning
          if (currentPlayer.state === 2) {
            console.log('[playMusic] Resuming from paused state');
            if (audioContext.state === 'suspended') {
              await audioContext.resume();
            }
            await currentPlayer.play();
          } else {
            console.log('[playMusic] Starting playback');
            await currentPlayer.play();
          }

          // Set up interval for playback monitoring
          playbackInterval = setInterval(() => {
            if (currentPlayer && currentPlayer.state === 1) {
              // Check if we've reached the end of playback
              if (currentPlayer.currentTime >= currentPlayer.duration) {
                clearPlaybackInterval();
                currentPlayer.stop();
                playBtn.disabled = false;
                pauseBtn.disabled = true;
                rewindBtn.disabled = false;
                console.log('[playMusic] Playback completed');
              }
            }
          }, 100);  // Check every 100ms
          
          console.log('[playMusic] Play/Resume successful. New state:', currentPlayer?.state);
        } catch (error) {
          console.error('Error playing music:', error);
          clearPlaybackInterval();
          // Reset to default state on error
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
          console.log('[playMusic] Error. Reset to default button state');
        }
      }

      // Function to handle pausing music
      async function pauseMusic() {
        console.log('[pauseMusic] Called. Current state:', currentPlayer?.state);
        if (!currentPlayer) {
          console.log('[pauseMusic] Aborted (no player).');
          return;
        }

        // Allow pause during playback
        if (currentPlayer.state !== 1) {
          console.log('[pauseMusic] Aborted (not playing).');
          return;
        }

        try {
          setButtonLoading(pauseBtn, true);
          clearPlaybackInterval();  // Clear interval before pausing

          // Set button states before pausing
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
          console.log('[pauseMusic] Setting button state: Play enabled, Pause disabled, Rewind enabled');

          await currentPlayer.pause();
          if (audioContext) {
            await audioContext.suspend();
          }
          console.log('[pauseMusic] Pause successful. New state:', currentPlayer?.state);
        } catch (error) {
          console.error('Error pausing music:', error);
          // Reset buttons based on current player state
          const isPlaying = currentPlayer.state === 1;
          playBtn.disabled = isPlaying;
          pauseBtn.disabled = !isPlaying;
          rewindBtn.disabled = false;
          console.log('[pauseMusic] Error. Reset buttons based on player state:', isPlaying ? 'playing' : 'paused');
        } finally {
          setButtonLoading(pauseBtn, false);
        }
      }

      // Rewind function
      async function rewind() {
        console.log('[rewind] Called. Current state:', currentPlayer?.state);
        if (!currentPlayer) {
          console.log('[rewind] Aborted (no player).');
          return;
        }

        try {
          setButtonLoading(rewindBtn, true);
          const wasPlaying = currentPlayer.state === 1;
          
          // Clear interval before any state changes
          clearPlaybackInterval();

          // If playing or paused, stop first
          if (currentPlayer.state !== 0) {
            console.log('[rewind] Stopping before rewind');
            try {
              await currentPlayer.stop();
            } catch (e) {
              console.warn('[rewind] Error stopping player:', e);
            }
            if (audioContext) {
              await audioContext.suspend();
            }
          }

          // Set button states before rewinding
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
          console.log('[rewind] Setting button state: Play enabled, Pause disabled, Rewind enabled');

          try {
            await currentPlayer.rewind();
            console.log('[rewind] Rewind successful. New state:', currentPlayer?.state);
          } catch (e) {
            console.warn('[rewind] Error during rewind:', e);
            // Even if rewind fails, try to reset to beginning
            if (typeof currentPlayer.seek === 'function') {
              await currentPlayer.seek(0);
            }
          }

          // If it was playing before, resume playing after a short delay
          if (wasPlaying) {
            console.log('[rewind] Resuming playback after rewind');
            setTimeout(async () => {
              try {
                await playMusic();
              } catch (e) {
                console.error('[rewind] Error resuming playback:', e);
              }
            }, 100);
          }
        } catch (error) {
          console.error('Error rewinding:', error);
          // Reset buttons based on current player state
          const isPlaying = currentPlayer.state === 1;
          playBtn.disabled = isPlaying;
          pauseBtn.disabled = !isPlaying;
          rewindBtn.disabled = false;
          console.log('[rewind] Error. Reset buttons based on player state:', isPlaying ? 'playing' : 'paused');
        } finally {
          setButtonLoading(rewindBtn, false);
        }
      }

      async function createNewPlayer(musicXmlData, selectedInstrumentId = null) {
        // Clear any existing intervals when creating a new player
        clearPlaybackInterval();
        
        if (!musicXmlData) {
          throw new Error('No MusicXML data provided');
        }

        currentMusicXml = musicXmlData;
        
        try {
          // Clear the sheet container
          document.getElementById('sheet-container').innerHTML = '';

          // Reset button states for new player (default state)
          console.log('[createNewPlayer] Setting initial button state: Play enabled, Pause disabled, Rewind enabled');
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;

          // Stop current player if exists
          if (currentPlayer) {
            try {
              await currentPlayer.pause();
              await currentPlayer.rewind();
              if (typeof currentPlayer.destroy === 'function') {
                await currentPlayer.destroy();
              }
            } catch (e) {
              console.warn('Error cleaning up previous player:', e);
            }
            currentPlayer = null;
          }

          // Clean up audio context only if we're changing instruments
          if (selectedInstrumentId !== currentInstrumentId) {
            if (audioContext) {
              await audioContext.close();
              audioContext = null;
            }
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }

          // Create player with current output
          const player = await Player.create({
            container: 'sheet-container',
            musicXml: musicXmlData,
            renderer: new VerovioRenderer(),
            converter: new VerovioConverter(),
            output: currentOutput
          });

          currentPlayer = player;

          // Apply settings
          try {
            const tempo = tempoControl.value;
            const semitones = parseInt(pitchControl.value);
            const frequency = parseInt(frequencyControl.value);
            
            if (havePitchSettingsChanged(semitones, frequency)) {
              const combinedPitch = Math.pow(2, (semitones + (frequency - 440) / 12) / 12);
              currentPlayer.pitch = combinedPitch;
              currentPitchSettings.semitones = semitones;
              currentPitchSettings.frequency = frequency;
            }
            
            currentPlayer.tempo = tempo / 120;
          } catch (e) {
            console.warn('Error applying settings:', e);
          }
          
          return player;
        } catch (error) {
          console.error('Error creating player:', error);
          const feedback = document.getElementById('feedback');
          if (feedback) {
            feedback.className = 'error';
            feedback.textContent = `Error: ${error.message || 'Failed to create player'}`;
          }
          console.log('[createNewPlayer] Error. Setting default button state: Play enabled, Pause disabled, Rewind enabled');
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
          throw error;
        }
      }

      async function loadFile(file) {
        const feedback = document.getElementById('feedback');
        feedback.className = 'loading';
        feedback.textContent = 'Loading file...';

        try {
          if (!file) {
            throw new Error('No file provided');
          }

          const content = await file.text();
          if (!content) {
            throw new Error('File is empty');
          }

          await createNewPlayer(content);
          feedback.className = 'success';
          feedback.textContent = 'File loaded successfully!';
        } catch (error) {
          console.error('File loading error:', error);
          feedback.className = 'error';
          feedback.textContent = `Error: ${error.message || 'Failed to load the file'}`;
          // Ensure buttons are in default state even on error
          console.log('[loadFile] Error. Setting default button state: Play enabled, Pause disabled, Rewind enabled');
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
        }
      }

      // Function to handle PDF uploads and conversion
      async function convertPdfToMusicXml(pdfFile) {
        const feedback = document.getElementById('pdf-feedback');
        const basicBtn = document.getElementById('convert-basic-btn');

        if (!pdfFile) {
          feedback.className = 'error';
          feedback.textContent = 'Please select a PDF or image file first.';
          return;
        }

        // Basic Conversion Call
        basicBtn.onclick = async () => {
          const formData = new FormData();
          formData.append('file', pdfFile);

          feedback.className = 'loading';
          feedback.innerHTML = '<span class="spinner"></span> Converting (basic)...';
          basicBtn.disabled = true;

          try {
            const response = await fetch('http://localhost:8000/convert', {
              method: 'POST',
              body: formData
            });

            if (!response.ok) {
              let errorMsg = `HTTP error! status: ${response.status}`;
              try {
                const errData = await response.json();
                errorMsg = errData.detail || errorMsg;
              } catch (e) { /* Ignore if response is not JSON */ }
              throw new Error(errorMsg);
            }

            const blob = await response.blob();
            
            // --- Handle potential MXL (ZIP) file ---
            let musicXmlText = '';
            // Check if it looks like a zip file (PK signature)
            const firstBytes = await blob.slice(0, 2).text();
            if (firstBytes === 'PK') {
              console.log('Detected ZIP/MXL format, attempting to unzip...');
              try {
                // Dynamically import unzipit from the local lib directory
                const { unzip, setOptions } = await import('./lib/unzipit.js'); 
                setOptions({ workerURL: './lib/sw.js' }); 

                const { entries } = await unzip(blob);
                console.log('Unzipped entries:', Object.keys(entries));

                // Find the main MusicXML file via container.xml
                let musicXmlPath = '';
                if (entries['META-INF/container.xml']) {
                  const containerText = await entries['META-INF/container.xml'].text();
                  const parser = new DOMParser();
                  const containerDoc = parser.parseFromString(containerText, 'application/xml');
                  musicXmlPath = containerDoc.querySelector('rootfile')?.getAttribute('full-path') || '';
                  console.log('Found path in container.xml:', musicXmlPath);
                } else {
                    // Fallback: find the first .musicxml or .xml file if container.xml is missing
                    musicXmlPath = Object.keys(entries).find(name => name.endsWith('.musicxml') || name.endsWith('.xml')) || '';
                    console.warn('container.xml not found, falling back to first XML file:', musicXmlPath);
                }

                if (musicXmlPath && entries[musicXmlPath]) {
                  musicXmlText = await entries[musicXmlPath].text();
                  console.log('Successfully extracted MusicXML from MXL.');
                } else {
                  throw new Error('Could not find a valid MusicXML file inside the archive.');
                }
              } catch (zipError) {
                console.error('Error processing MXL file:', zipError);
                throw new Error(`Failed to read MXL file: ${zipError.message}`);
              }
            } else {
              // Assume plain text if not starting with PK
              console.log('Assuming plain MusicXML format.');
              musicXmlText = await blob.text();
            }
            // --- End MXL handling ---
            
            // --- DEBUGGING: Log the received text ---
            console.log('Received MusicXML Text (Basic, after potential unzip):', musicXmlText.substring(0, 500) + (musicXmlText.length > 500 ? '...' : ''));
            // --- END DEBUGGING ---

            feedback.textContent = 'Conversion successful! Loading score...';
            const success = await createNewPlayer(musicXmlText);

            if (success) {
              feedback.className = 'success';
              feedback.textContent = 'Conversion successful! Score loaded.';
              // createNewPlayer sets the buttons, no need to repeat here
            } else {
              feedback.className = 'error';
              feedback.textContent = 'Conversion successful, but failed to load the score into the player.';
              // Set default state if player load failed after conversion
              console.log('[convertPdfToMusicXml] Player load failed. Setting default button state.');
              playBtn.disabled = false;
              pauseBtn.disabled = true;
              rewindBtn.disabled = false;
            }
          } catch (error) {
            console.error('Basic conversion error:', error);
            feedback.className = 'error';
            feedback.textContent = `Error: ${error.message}`;
            // Ensure buttons are in default state on conversion error
            console.log('[convertPdfToMusicXml] Conversion Error. Setting default button state.');
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            rewindBtn.disabled = false;
          } finally {
            basicBtn.disabled = false;
          }
        };
      }

      // Event listener for PDF file input change
      document.getElementById('pdf-input').addEventListener('change', (event) => {
        const file = event.target.files[0];
        const feedback = document.getElementById('pdf-feedback');
        const basicBtn = document.getElementById('convert-basic-btn');

        if (file) {
          feedback.className = '';
          feedback.textContent = `Selected: ${file.name}`;
          // Prepare the conversion functions with the selected file
          convertPdfToMusicXml(file);
          basicBtn.disabled = false; // Enable buttons now that a file is selected
        } else {
          feedback.className = '';
          feedback.textContent = '';
          basicBtn.disabled = true; // Disable buttons if no file is selected
          // Clear old handlers if any (or re-run convertPdfToMusicXml with null)
          convertPdfToMusicXml(null);
        }
      });

      // Initially disable conversion buttons
      document.getElementById('convert-basic-btn').disabled = true;

      // Event listener for MusicXML file input change
      document.getElementById('file-input').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          loadFile(file);
        }
      });

      // Set up sample selector
      document.getElementById('samples').addEventListener('change', async (event) => {
        const sample = event.target.value;
        if (sample) {
          const feedback = document.getElementById('feedback');
          feedback.className = 'loading';
          feedback.textContent = 'Loading sample...';
          
          try {
            const response = await fetch(sample);
            const content = await response.text();
            await createNewPlayer(content);
            
            // createNewPlayer sets the buttons
            feedback.className = 'success';
            feedback.textContent = 'Sample loaded successfully!';
          } catch (error) {
            console.error('Error loading sample:', error);
            feedback.className = 'error';
            feedback.textContent = 'Error loading sample file.';
            // Ensure buttons are in default state on sample load error
            console.log('[samples.onChange] Error. Setting default button state.');
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            rewindBtn.disabled = false;
          }
        }
      });

      // Handle instrument selection
      document.getElementById('instrumentSelector').addEventListener('change', async (event) => {
        const selectedInstrumentId = event.target.value;
        if (!currentMusicXml || selectedInstrumentId === currentInstrumentId) return;

        try {
          console.log('[instrumentSelector.onChange] Changing instrument to:', selectedInstrumentId);
          await initializeSoundFont(selectedInstrumentId, true);
          await createNewPlayer(currentMusicXml, selectedInstrumentId);
        } catch (error) {
          console.error('Error changing instrument:', error);
          console.log('[instrumentSelector.onChange] Error. Setting default button state.');
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
        }
      });

      // Add tempo, pitch, and frequency control handlers
      const tempoControl = document.getElementById('tempoControl');
      const tempoValue = document.getElementById('tempoValue');
      const pitchControl = document.getElementById('pitchControl');
      const pitchValue = document.getElementById('pitchValue');
      const frequencyControl = document.getElementById('frequencyControl');
      const frequencyValue = document.getElementById('frequencyValue');

      // Standard A4 reference frequency
      const STANDARD_A4 = 440;

      // Update pitch function
      function updatePitch() {
        if (!currentPlayer) return;

        try {
          const semitones = parseInt(pitchControl.value);
          const frequency = parseInt(frequencyControl.value);
          
          // Check if pitch settings have actually changed
          if (!havePitchSettingsChanged(semitones, frequency)) {
            console.log('[updatePitch] Pitch settings unchanged, skipping update');
            return;
          }

          // Calculate combined pitch adjustment
          const frequencyRatio = frequency / STANDARD_A4;
          const semitonePitch = Math.pow(2, semitones / 12);
          const combinedPitch = frequencyRatio * semitonePitch;
          
          currentPlayer.pitch = combinedPitch;
          
          // Update current settings
          currentPitchSettings.semitones = semitones;
          currentPitchSettings.frequency = frequency;
          
          console.log('[updatePitch] Updated pitch settings:', { semitones, frequency, combinedPitch });
        } catch (error) {
          console.error('Error updating pitch:', error);
        }
      }

      // Update tempo display and player
      tempoControl.addEventListener('input', (event) => {
        const tempo = event.target.value;
        tempoValue.textContent = tempo;
        if (currentPlayer) {
          try {
            currentPlayer.tempo = tempo / 120; // Normalize tempo (120 BPM is the base tempo)
          } catch (error) {
            console.error('Error setting tempo:', error);
          }
        }
      });

      // Update transpose display and player
      pitchControl.addEventListener('input', (event) => {
        const semitones = event.target.value;
        pitchValue.textContent = semitones;
        updatePitch();
      });

      // Update frequency display and player
      frequencyControl.addEventListener('input', (event) => {
        const frequency = event.target.value;
        frequencyValue.textContent = frequency;
        updatePitch();
      });

      // Update the default sample loading code
      async function loadDefaultSample() {
        try {
          const response = await fetch('data/asa-branca.musicxml');
          const content = await response.text();
          await createNewPlayer(content);
          
          // createNewPlayer sets the buttons
        } catch (error) {
          console.error('Error loading default sample:', error);
          const feedback = document.getElementById('feedback');
          if (feedback) {
            feedback.className = 'error';
            feedback.textContent = 'Error loading default sample. Please try uploading your own file.';
          }
          // Set initial button state even on error
          console.log('[loadDefaultSample] Error. Setting default button state.');
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
        }
      }

      // Load default sample
      loadDefaultSample();

      // Set up control button event listeners
      playBtn.addEventListener('click', playMusic);
      pauseBtn.addEventListener('click', pauseMusic);
      rewindBtn.addEventListener('click', rewind);

      // Initial button state is set within createNewPlayer/loadDefaultSample
      // but we can set it here explicitly for absolute certainty on page load
      console.log('Initial page load: Setting default button state.');
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      rewindBtn.disabled = false;
    </script>
  </body>
</html>
