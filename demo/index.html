<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
    <title>MusicXML Player Demo</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎵</text></svg>">
    <style>
      :root {
        --primary-color: #4a90e2;
        --secondary-color: #f8f9fa;
        --text-color: #2c3e50;
        --border-radius: 8px;
      }

      body {
        background-color: var(--secondary-color);
        font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        margin: 0;
        padding: 20px;
        color: var(--text-color);
      }

      .hide {
        display: none;
      }

      h1 {
        text-align: center;
        color: var(--primary-color);
        margin-bottom: 30px;
        font-size: 2.5em;
      }

      .main-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      .controls-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .upload-section {
        background: white;
        padding: 20px;
        border-radius: var(--border-radius);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
      }

      .upload-section:hover {
        transform: translateY(-2px);
      }

      .upload-section h3 {
        margin: 0 0 15px 0;
        color: var(--primary-color);
        font-size: 1.2em;
      }

      input[type="file"] {
        width: 100%;
        padding: 10px;
        border: 2px dashed #ddd;
        border-radius: var(--border-radius);
        margin-bottom: 10px;
        cursor: pointer;
      }

      input[type="file"]:hover {
        border-color: var(--primary-color);
      }

      select {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        background: white;
        cursor: pointer;
      }

      #sheet-container {
        height: calc(100vh - 300px);
        margin: 20px 0;
        border-radius: var(--border-radius);
        background: white;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow-y: auto;
        padding: 20px;
        margin-bottom: 100px;
      }

      .player-controls {
        display: flex;
        align-items: center;
        gap: 20px;
        background: white;
        padding: 15px 30px;
        border-radius: var(--border-radius);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        flex-wrap: wrap;
      }

      .controls-group {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .playback-controls {
        display: flex;
        align-items: center;
        gap: 30px;
        flex-wrap: wrap;
      }

      .slider-control {
        position: relative;
        transition: opacity 0.3s;
      }

      .slider-control::before {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        padding: 5px 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 4px;
        font-size: 12px;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
        white-space: nowrap;
        pointer-events: none;
      }

      .slider-control:hover::before {
        opacity: 1;
        visibility: visible;
        bottom: calc(100% + 5px);
      }

      .slider-control input[type="range"].adjusting {
        background: var(--primary-color);
      }

      .slider-control input[type="range"].processing {
        opacity: 0.7;
        cursor: wait;
      }

      .slider-control input[type="range"].success {
        background: #2ecc71;
        transition: background 0.3s;
      }

      .slider-control input[type="range"].error {
        background: #e74c3c;
        transition: background 0.3s;
      }

      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
      }

      .loading-overlay.active {
        opacity: 1;
        visibility: visible;
      }

      .loading-content {
        text-align: center;
        color: var(--primary-color);
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid rgba(74, 144, 226, 0.3);
        border-radius: 50%;
        border-top-color: var(--primary-color);
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      .loading-text {
        font-size: 16px;
        margin-top: 10px;
      }

      .progress-bar {
        width: 200px;
        height: 4px;
        background: rgba(74, 144, 226, 0.2);
        border-radius: 2px;
        margin: 10px auto;
        overflow: hidden;
      }

      .progress-bar-fill {
        height: 100%;
        background: var(--primary-color);
        width: 0%;
        transition: width 0.3s;
      }

      /* Enhanced tooltips for controls */
      [data-tooltip] {
        position: relative;
      }

      [data-tooltip]:hover::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        padding: 5px 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 1000;
      }

      /* Status indicators */
      .status-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-left: 5px;
        transition: all 0.3s;
      }

      .status-indicator.loading {
        background: var(--primary-color);
        animation: pulse 1s infinite;
      }

      .status-indicator.success {
        background: #2ecc71;
      }

      .status-indicator.error {
        background: #e74c3c;
      }

      @keyframes pulse {
        0% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.2); opacity: 0.5; }
        100% { transform: scale(1); opacity: 1; }
      }

      .player {
        font-size: 22px;
        width: 44px;
        height: 44px;
        border: none;
        border-radius: 50%;
        background: var(--primary-color);
        color: white;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        line-height: 1;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .player:hover {
        transform: scale(1.05);
        background: #357abd;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .player:active {
        transform: scale(0.95);
      }

      .player:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .player#playPause { 
        width: 52px;
        height: 52px;
        font-size: 24px;
      }

      .player#playPause[title="Stop"] {
        background-color: #e74c3c;
      }

      .player#playPause[title="Stop"]:hover {
        background-color: #c0392b;
      }

      .instrument-selector {
        min-width: 220px;
        padding: 10px 15px;
        border: 1px solid #ddd;
        border-radius: var(--border-radius);
        font-size: 14px;
        color: var(--text-color);
        background: white;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .instrument-selector:hover {
        border-color: var(--primary-color);
      }

      .instrument-selector:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
      }

      #player {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background: rgba(255, 255, 255, 0.95);
        padding: 15px;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        z-index: 1000;
        display: flex;
        justify-content: center;
      }

      #play {
        padding-left: 3px;
      }

      #pause {
        font-size: 18px;
      }

      #rewind {
        font-size: 16px;
      }

      #feedback, #pdf-feedback {
        margin-top: 10px;
        padding: 10px;
        border-radius: var(--border-radius);
        font-size: 0.9em;
      }

      .success { 
        color: #2ecc71;
        background: #e8f8f5;
      }

      .error { 
        color: #e74c3c;
        background: #fdedec;
      }

      .loading { 
        color: var(--primary-color);
        background: #eef7ff;
      }

      .spinner {
        border: 3px solid rgba(74, 144, 226, 0.1);
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border-left-color: var(--primary-color);
        animation: spin 1s linear infinite;
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      button {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: var(--border-radius);
        cursor: pointer;
        transition: background 0.2s;
      }

      button:hover {
        background: #357abd;
      }

      .player-loading {
        position: relative;
      }

      .player-loading::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 16px;
        height: 16px;
        margin: -8px 0 0 -8px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s linear infinite;
      }

      .player-loading.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .instrument-selector.loading {
        position: relative;
        pointer-events: none;
        opacity: 0.7;
      }
      .instrument-selector.loading::after {
        content: '';
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        width: 16px;
        height: 16px;
        border: 2px solid rgba(74, 144, 226, 0.3);
        border-radius: 50%;
        border-top-color: var(--primary-color);
        animation: spin 0.8s linear infinite;
      }
    </style>
    <link rel="stylesheet" href="build/musicxml-player.css">
  </head>
  <body>
    <div class="loading-overlay">
      <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading...</div>
        <div class="progress-bar">
          <div class="progress-bar-fill"></div>
        </div>
      </div>
    </div>
    <div class="main-container">
      <h1>MusicXML Player</h1>

      <div class="controls-grid">
        <div class="upload-section">
          <h3>Upload MusicXML File</h3>
          <input type="file" id="file-input" accept=".musicxml,.mxl,.xml"/>
          <div id="feedback"></div>
        </div>

        <div class="upload-section">
          <h3>Convert Score to MusicXML</h3>
          <input type="file" id="pdf-input" accept=".pdf,image/*" placeholder="Upload PDF or Image"/>
          <button id="convert-basic-btn">Convert Score</button>
          <div id="pdf-feedback"></div>
        </div>

        <div class="upload-section">
          <h3>Sample Scores</h3>
          <select id="samples">
            <option value="">-- Choose a sample --</option>
            <option value="data/asa-branca.musicxml">Asa Branca</option>
            <option value="data/bach-invention-1.musicxml">Bach Invention No. 1</option>
            <option value="data/chopin-prelude-20.musicxml">Chopin Prelude No. 20</option>
            <option value="data/debussy-clair-de-lune.musicxml">Debussy Clair de Lune</option>
          </select>
        </div>
      </div>

      <div id="sheet-container"></div>

      <div id="player">
        <div class="player-controls">
          <div class="playback-controls">
            <div class="controls-group">
              <button class="player" id="rewind" title="Rewind">⏮</button>
              <button class="player" id="play" title="Play">▶</button>
              <button class="player" id="pause" title="Pause">⏸</button>
            </div>
            <div class="slider-control" data-tooltip="Adjust playback speed">
              <label>Tempo (BPM)</label>
              <input type="range" id="tempoControl" min="40" max="208" value="120" step="1">
              <span class="value" id="tempoValue">120</span>
              <span class="status-indicator"></span>
            </div>
            <div class="slider-control" data-tooltip="Transpose the music up or down">
              <label>Transpose (semitones)</label>
              <input type="range" id="pitchControl" min="-12" max="12" value="0" step="1">
              <span class="value" id="pitchValue">0</span>
              <span class="status-indicator"></span>
            </div>
            <div class="slider-control" data-tooltip="Adjust reference pitch (A4)">
              <label>Pitch (Hz)</label>
              <input type="range" id="frequencyControl" min="380" max="480" value="440" step="1">
              <span class="value" id="frequencyValue">440</span>
              <span class="status-indicator"></span>
            </div>
          </div>
          <select id="instrumentSelector" class="instrument-selector">
            <option value="">Select Instrument...</option>
            <optgroup label="Piano">
              <option value="0">Acoustic Grand Piano</option>
              <option value="1">Bright Acoustic Piano</option>
              <option value="4">Electric Piano</option>
              <option value="6">Harpsichord</option>
            </optgroup>
            <optgroup label="Percussion">
              <option value="11">Vibraphone</option>
              <option value="12">Marimba</option>
              <option value="13">Xylophone</option>
            </optgroup>
            <optgroup label="Strings">
              <option value="40">Violin</option>
              <option value="41">Viola</option>
              <option value="42">Cello</option>
              <option value="43">Contrabass</option>
            </optgroup>
            <optgroup label="Brass">
              <option value="56">Trumpet</option>
              <option value="57">Trombone</option>
              <option value="58">Tuba</option>
            </optgroup>
            <optgroup label="Woodwinds">
              <option value="68">Oboe</option>
              <option value="71">Clarinet</option>
              <option value="73">Flute</option>
              <option value="70">Bassoon</option>
            </optgroup>
            <optgroup label="Guitar">
              <option value="24">Acoustic Guitar (Nylon)</option>
              <option value="25">Acoustic Guitar (Steel)</option>
              <option value="26">Electric Guitar (Jazz)</option>
            </optgroup>
          </select>
        </div>
      </div>
    </div>

    <!-- Add unzip library -->
    <script src="https://unpkg.com/unzipit@1.4.3/dist/unzipit.min.js"></script>
    <script type="module">
      import {
        Player,
        VerovioConverter,
        VerovioRenderer,
        SoundFontOutput
      } from './build/musicxml-player.mjs';

      let currentPlayer = null;
      let currentMusicXml = null;
      let currentOutput = null;
      let isProcessing = false;
      let isLoadingSoundFont = false;
      let audioContext = null;
      let soundFontLoaded = false;
      let currentInstrumentId = null;
      let playbackInterval = null;  // Add interval tracking
      let currentPitchSettings = {
        semitones: 0,
        frequency: 440
      };

      // Get button elements (do this once)
      const playBtn = document.getElementById('play');
      const pauseBtn = document.getElementById('pause');
      const rewindBtn = document.getElementById('rewind');

      // Loading overlay management
      const loadingOverlay = {
        overlay: document.querySelector('.loading-overlay'),
        text: document.querySelector('.loading-text'),
        progress: document.querySelector('.progress-bar-fill'),
        
        show(message = 'Loading...') {
          this.text.textContent = message;
          this.progress.style.width = '0%';
          this.overlay.classList.add('active');
        },
        
        hide() {
          this.overlay.classList.remove('active');
        },
        
        setProgress(percent) {
          this.progress.style.width = `${percent}%`;
        },
        
        updateMessage(message) {
          this.text.textContent = message;
        }
      };

      // Function to show loading state on a button
      function setButtonLoading(button, isLoading) {
        if (isLoading) {
          button.classList.add('player-loading');
          button.disabled = true;  // Disable button while loading
        } else {
          button.classList.remove('player-loading');
          button.disabled = false; // Re-enable button after loading
        }
      }

      // Function to show loading state on instrument selector
      function setInstrumentSelectorLoading(isLoading) {
        const selector = document.getElementById('instrumentSelector');
        if (isLoading) {
          selector.classList.add('loading');
          selector.disabled = true;
        } else {
          selector.classList.remove('loading');
          selector.disabled = false;
        }
      }

      // Function to check if pitch settings have changed
      function havePitchSettingsChanged(newSemitones, newFrequency) {
        return currentPitchSettings.semitones !== newSemitones || 
               currentPitchSettings.frequency !== newFrequency;
      }

      // Function to initialize or reinitialize SoundFont
      async function initializeSoundFont(instrumentId, force = false) {
        if (!force && soundFontLoaded && instrumentId === currentInstrumentId) {
          console.log('[initializeSoundFont] SoundFont already loaded for instrument:', instrumentId);
          return;
        }

        isLoadingSoundFont = true;
        setInstrumentSelectorLoading(true);  // Show loading state on selector
        
        try {
          console.log('[initializeSoundFont] Initializing SoundFont for instrument:', instrumentId);

          // Initialize audio context if needed
          if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }

          // Resume audio context if suspended
          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }

          // Clean up previous output
          if (currentOutput) {
            try {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.reset === 'function') {
                await currentOutput.reset();
              }
              if (typeof currentOutput.destroy === 'function') {
                await currentOutput.destroy();
              }
            } catch (e) {
              console.warn('Error cleaning up previous output:', e);
            }
            currentOutput = null;
          }

          // Create new output with selected instrument
          const midiJson = {
            division: 480,
            tracks: [[{
              channel: 0,
              programChange: {
                programNumber: parseInt(instrumentId)
              }
            }]]
          };

          currentOutput = new SoundFontOutput(midiJson);
          await currentOutput.initialize();
          soundFontLoaded = true;
          currentInstrumentId = instrumentId;
          console.log('[initializeSoundFont] SoundFont initialized successfully');
        } catch (e) {
          console.error('Error initializing SoundFont:', e);
          currentOutput = null;
          soundFontLoaded = false;
          currentInstrumentId = null;
          throw e;
        } finally {
          isLoadingSoundFont = false;
          setInstrumentSelectorLoading(false);  // Hide loading state on selector
        }
      }

      // Add state tracking
      let activeIntervals = new Map();
      let currentWorker = null;
      let workerInterval = null;
      let isCleaningUp = false;

      // Function to safely clear interval and worker
      function clearPlaybackInterval() {
        try {
          // Clear the actual interval if it exists
          if (workerInterval) {
            clearInterval(workerInterval);
            workerInterval = null;
          }

          // Stop and cleanup the worker
          if (currentWorker) {
            try {
              currentWorker.postMessage({ type: 'stop' });
              currentWorker.terminate();
            } catch (e) {
              console.warn('[clearPlaybackInterval] Error terminating worker:', e);
            }
            currentWorker = null;
          }

          // Clear tracking
          activeIntervals.clear();
          playbackInterval = null;
          
          console.log('[clearPlaybackInterval] Cleared interval and worker');
        } catch (e) {
          console.warn('[clearPlaybackInterval] Error during cleanup:', e);
        }
      }

      // Enhanced cleanup function
      async function cleanupPlayer() {
        if (isCleaningUp) return;
        isCleaningUp = true;
        
        try {
          clearPlaybackInterval();

          if (currentPlayer) {
            try {
              // First try to pause any ongoing playback
              if (typeof currentPlayer.pause === 'function') {
                await currentPlayer.pause();
              }

              // Clear the sheet container before destroying the player
              const container = document.getElementById('sheet-container');
              if (container) {
                container.innerHTML = '';
              }

              // Then try to destroy the player
              if (typeof currentPlayer.destroy === 'function') {
                await currentPlayer.destroy();
              }
            } catch (e) {
              console.warn('[cleanupPlayer] Error cleaning up player:', e);
            }
            currentPlayer = null;
          }

          // Clean up audio context if needed
          if (audioContext && audioContext.state === 'running') {
            try {
              await audioContext.suspend();
            } catch (e) {
              console.warn('[cleanupPlayer] Error suspending audio context:', e);
            }
          }

          // Clean up output if available
          if (currentOutput) {
            try {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.reset === 'function') {
                await currentOutput.reset();
              }
              if (typeof currentOutput.destroy === 'function') {
                await currentOutput.destroy();
              }
            } catch (e) {
              console.warn('[cleanupPlayer] Error cleaning up output:', e);
            }
            currentOutput = null;
          }
        } finally {
          isCleaningUp = false;
        }
      }

      // Function to safely handle player state changes
      async function safePlayerStateChange(action) {
        if (!currentPlayer) return false;
        
        try {
          if (typeof currentPlayer[action] === 'function') {
            await currentPlayer[action]();
            return true;
          } else {
            console.warn(`[safePlayerStateChange] ${action} is not a function`);
            // Fallback behaviors for missing methods
            if (action === 'stop') {
              if (typeof currentPlayer.pause === 'function') {
                await currentPlayer.pause();
                if (typeof currentPlayer.seek === 'function') {
                  await currentPlayer.seek(0);
                }
                return true;
              }
            }
            return false;
          }
        } catch (e) {
          console.warn(`[safePlayerStateChange] Error during ${action}:`, e);
          return false;
        }
      }

      // Function to safely initialize audio context
      async function initializeAudioContext() {
        try {
          if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          return true;
        } catch (e) {
          console.error('Error initializing audio context:', e);
          loadingOverlay.updateMessage('Error initializing audio. Please reload the page.');
          return false;
        }
      }

      // Enhanced createNewPlayer with better instrument handling
      async function createNewPlayer(musicXmlData, selectedInstrumentId = null) {
        loadingOverlay.show('Initializing player...');
        
        if (!musicXmlData) {
          loadingOverlay.hide();
          throw new Error('No MusicXML data provided');
        }

        currentMusicXml = musicXmlData;
        
        try {
          loadingOverlay.setProgress(20);
          loadingOverlay.updateMessage('Clearing previous state...');
          
          // Clean up previous state
          await cleanupPlayer();

          // Only initialize audio context if we have a selected instrument
          // This allows loading the score without starting audio
          if (selectedInstrumentId) {
            loadingOverlay.setProgress(40);
            loadingOverlay.updateMessage('Initializing audio...');
            
            // Initialize audio context
            const audioContextReady = await initializeAudioContext();
            if (!audioContextReady) {
              throw new Error('Failed to initialize audio context');
            }

            // Initialize SoundFont if instrument is selected
            loadingOverlay.updateMessage('Loading instrument sounds...');
            await initializeSoundFont(selectedInstrumentId, true);
          }

          loadingOverlay.setProgress(80);
          loadingOverlay.updateMessage('Creating player...');
          
          // Create player with current output
          const player = await Player.create({
            container: 'sheet-container',
            musicXml: musicXmlData,
            renderer: new VerovioRenderer(),
            converter: new VerovioConverter(),
            output: currentOutput,
            audioContext: audioContext
          });

          currentPlayer = player;

          // Only apply audio settings if we have an instrument selected
          if (selectedInstrumentId) {
            loadingOverlay.setProgress(90);
            loadingOverlay.updateMessage('Applying settings...');
            
            try {
              const tempo = tempoControl.value;
              const semitones = parseInt(pitchControl.value);
              const frequency = parseInt(frequencyControl.value);
              
              if (havePitchSettingsChanged(semitones, frequency)) {
                const combinedPitch = Math.pow(2, (semitones + (frequency - 440) / 12) / 12);
                currentPlayer.pitch = combinedPitch;
                currentPitchSettings.semitones = semitones;
                currentPitchSettings.frequency = frequency;
              }
              
              currentPlayer.tempo = parseFloat(tempo) / 120;
            } catch (e) {
              console.warn('Error applying settings:', e);
            }
          }

          loadingOverlay.setProgress(100);
          loadingOverlay.updateMessage('Ready!');
          setTimeout(() => loadingOverlay.hide(), 500);
          
          return player;
        } catch (error) {
          console.error('Error creating player:', error);
          loadingOverlay.updateMessage(`Error: ${error.message}`);
          setTimeout(() => loadingOverlay.hide(), 2000);
          
          const feedback = document.getElementById('feedback');
          if (feedback) {
            feedback.className = 'error';
            feedback.textContent = `Error: ${error.message || 'Failed to create player'}`;
          }
          
          // Clean up on error
          await cleanupPlayer();
          
          // Reset to default state
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
          
          throw error;
        }
      }

      // Function to handle file selection
      async function handleFileSelect(e) {
        const file = e.target.files[0];
        if (!file) return;

        const feedback = document.getElementById('feedback');
        feedback.textContent = 'Processing file...';
        feedback.className = '';

        try {
          const buffer = await file.arrayBuffer();
          
          // Check if it's an MXL file (ZIP format)
          const isZip = file.name.toLowerCase().endsWith('.mxl') || 
                       (new Uint8Array(buffer.slice(0, 2)).toString() === '80,75'); // PK header

          let musicXmlText;
          if (isZip) {
            console.log('Detected MXL (compressed MusicXML) format');
            feedback.textContent = 'Extracting compressed MusicXML...';
            
            try {
              console.log('Starting MXL extraction...');
              // Use the global unzipit function
              const { entries } = await window.unzipit.unzip(buffer);
              console.log('Available files in MXL:', Object.keys(entries));
              
              // First try to find the rootfile from container.xml
              let rootFile;
              if (entries['META-INF/container.xml']) {
                console.log('Found container.xml, parsing...');
                const containerXml = await entries['META-INF/container.xml'].text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(containerXml, 'text/xml');
                rootFile = doc.querySelector('rootfile')?.getAttribute('full-path');
                console.log('Root file path from container.xml:', rootFile);
              }
              
              // If we found the rootfile, use it, otherwise try to find any .xml file
              if (rootFile && entries[rootFile]) {
                console.log('Loading MusicXML from root file:', rootFile);
                musicXmlText = await entries[rootFile].text();
              } else {
                // Look for any .xml file in the archive
                const xmlFiles = Object.keys(entries).filter(name => name.toLowerCase().endsWith('.xml'));
                if (xmlFiles.length > 0) {
                  console.log('Using first XML file:', xmlFiles[0]);
                  musicXmlText = await entries[xmlFiles[0]].text();
                } else {
                  throw new Error('No MusicXML file found in the MXL archive');
                }
              }

              if (!musicXmlText || !musicXmlText.trim()) {
                throw new Error('Extracted MusicXML is empty');
              }
              console.log('Successfully extracted MusicXML content');
              
            } catch (error) {
              console.error('MXL extraction error:', error);
              throw new Error(`Failed to extract MXL file: ${error.message}`);
            }
          } else {
            // Try to parse as regular MusicXML
            try {
              musicXmlText = new TextDecoder().decode(buffer);
              const parser = new DOMParser();
              const doc = parser.parseFromString(musicXmlText, 'text/xml');
              if (doc.querySelector('parsererror')) {
                throw new Error('Invalid XML format');
              }
            } catch (error) {
              throw new Error(`Invalid MusicXML format: ${error.message}`);
            }
          }

          // Create player with default output
          await createNewPlayer(musicXmlText);
          
          feedback.className = 'success';
          feedback.textContent = 'Score loaded successfully! Ready to play.';

        } catch (error) {
          console.error('File processing error:', error);
          feedback.className = 'error';
          feedback.textContent = `Error: ${error.message}`;
          currentMusicXml = null;
        }

        // Reset file input
        e.target.value = '';
      }

      // Function to handle PDF uploads and conversion
      async function convertPdfToMusicXml(pdfFile) {
        const feedback = document.getElementById('pdf-feedback');
        const basicBtn = document.getElementById('convert-basic-btn');

        if (!pdfFile) {
          feedback.className = 'error';
          feedback.textContent = 'Please select a PDF or image file first.';
          return;
        }

        // Basic Conversion Call
        basicBtn.onclick = async () => {
          const formData = new FormData();
          formData.append('file', pdfFile);
          formData.append('filename', pdfFile.name);
          formData.append('filetype', pdfFile.type);

          feedback.className = 'loading';
          feedback.innerHTML = '<span class="spinner"></span> Converting PDF to MusicXML...';
          basicBtn.disabled = true;

          try {
            // First validate the file
            if (!pdfFile.type.includes('pdf') && !pdfFile.type.includes('image')) {
              throw new Error('Please upload a PDF or image file.');
            }

            // Make the API call to convert
            const response = await fetch('http://localhost:8000/convert', {
              method: 'POST',
              body: formData,
              headers: {
                'Accept': 'application/xml, application/x-zip'
              }
            });

            if (!response.ok) {
              let errorMsg = `Conversion failed! Status: ${response.status}`;
              try {
                const errData = await response.json();
                errorMsg = errData.detail || errorMsg;
              } catch (e) {
                console.warn('Error parsing error response:', e);
              }
              throw new Error(errorMsg);
            }

            const contentType = response.headers.get('Content-Type');
            const blob = await response.blob();
            
            let musicXmlText = '';

            // Handle different response types
            if (contentType?.includes('zip') || contentType?.includes('mxl') || 
                (blob.size > 0 && (await blob.slice(0, 2).text()) === 'PK')) {
              console.log('Processing MXL/ZIP response...');
              
              try {
                const { entries } = await window.unzipit.unzip(blob);
                console.log('ZIP entries:', Object.keys(entries));

                // Try to find the main MusicXML file
                let musicXmlEntry;

                // First check container.xml if it exists
                if (entries['META-INF/container.xml']) {
                  const containerText = await entries['META-INF/container.xml'].text();
                  const parser = new DOMParser();
                  const containerDoc = parser.parseFromString(containerText, 'application/xml');
                  const rootfilePath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
                  
                  if (rootfilePath && entries[rootfilePath]) {
                    musicXmlEntry = entries[rootfilePath];
                  }
                }

                // Fallback: look for any .musicxml or .xml file
                if (!musicXmlEntry) {
                  musicXmlEntry = Object.values(entries).find(entry => 
                    entry.name.endsWith('.musicxml') || entry.name.endsWith('.xml')
                  );
                }

                if (!musicXmlEntry) {
                  throw new Error('No MusicXML file found in the converted package');
                }

                musicXmlText = await musicXmlEntry.text();
                console.log('Successfully extracted MusicXML from package');

              } catch (zipError) {
                console.error('Error processing MXL/ZIP:', zipError);
                throw new Error(`Failed to process converted file: ${zipError.message}`);
              }
            } else {
              // Assume direct MusicXML response
              musicXmlText = await blob.text();
            }

            // Validate the MusicXML
            if (!musicXmlText.trim().startsWith('<?xml') || !musicXmlText.includes('<score-partwise')) {
              throw new Error('Invalid MusicXML received from conversion');
            }

            feedback.textContent = 'Conversion successful! Loading score...';
            
            // Get current instrument selection
            const instrumentSelector = document.getElementById('instrumentSelector');
            const selectedInstrumentId = instrumentSelector.value;
            
            // Create new player with the converted MusicXML and selected instrument
            await createNewPlayer(musicXmlText, selectedInstrumentId || null);
            
            feedback.className = 'success';
            feedback.textContent = 'PDF successfully converted and loaded!';

          } catch (error) {
            console.error('PDF conversion error:', error);
            feedback.className = 'error';
            feedback.textContent = `Conversion failed: ${error.message}`;
          } finally {
            basicBtn.disabled = false;
          }
        };
      }

      // Function to clear all feedback messages
      function clearAllFeedback() {
        const feedbacks = ['feedback', 'pdf-feedback'];
        feedbacks.forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.textContent = '';
            element.className = '';
          }
        });
      }

      // Update sample selector handler
      document.getElementById('samples').addEventListener('change', async (event) => {
        const sample = event.target.value;
        if (sample) {
          clearAllFeedback(); // Clear previous messages
          const feedback = document.getElementById('feedback');
          feedback.className = 'loading';
          feedback.textContent = 'Loading sample...';
          
          try {
            const response = await fetch(sample);
            const content = await response.text();
            await createNewPlayer(content);
            
            feedback.className = 'success';
            feedback.textContent = 'Sample score loaded successfully!';
            
            // Clear any PDF upload state
            document.getElementById('pdf-input').value = '';
          } catch (error) {
            console.error('Error loading sample:', error);
            feedback.className = 'error';
            feedback.textContent = 'Error loading sample score.';
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            rewindBtn.disabled = false;
          }
        }
      });

      // Update file input handler
      document.getElementById('file-input').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          clearAllFeedback(); // Clear previous messages
          handleFileSelect(event);
          // Clear PDF input and sample selector
          document.getElementById('pdf-input').value = '';
          document.getElementById('samples').value = '';
        }
      });

      // Update PDF file input handler
      document.getElementById('pdf-input').addEventListener('change', (event) => {
        const file = event.target.files[0];
        const feedback = document.getElementById('pdf-feedback');
        const basicBtn = document.getElementById('convert-basic-btn');

        clearAllFeedback(); // Clear previous messages

        if (file) {
          // Validate file type
          if (!file.type.includes('pdf') && !file.type.includes('image')) {
            feedback.className = 'error';
            feedback.textContent = 'Please select a PDF or image file of sheet music.';
            basicBtn.disabled = true;
            return;
          }

          feedback.className = 'info';
          feedback.textContent = `Selected: ${file.name}`;
          convertPdfToMusicXml(file);
          basicBtn.disabled = false;

          // Clear other inputs
          document.getElementById('file-input').value = '';
          document.getElementById('samples').value = '';
        } else {
          feedback.textContent = '';
          basicBtn.disabled = true;
          convertPdfToMusicXml(null);
        }
      });

      // Update default sample loading
      async function loadDefaultSample() {
        try {
          const response = await fetch('data/asa-branca.musicxml');
          const content = await response.text();
          
          // Create player without initializing audio context
          await createNewPlayer(content);
          
          const feedback = document.getElementById('feedback');
          feedback.className = 'success';
          feedback.textContent = 'Default score loaded successfully! Click play to start.';
          
          // Update the samples dropdown to show the current selection
          const samplesSelect = document.getElementById('samples');
          samplesSelect.value = 'data/asa-branca.musicxml';
        } catch (error) {
          console.error('Error loading default sample:', error);
          const feedback = document.getElementById('feedback');
          feedback.className = 'error';
          feedback.textContent = 'Error loading default score. Please try uploading your own file.';
          currentMusicXml = null;
        }
      }

      // Load default sample without creating player
      loadDefaultSample();

      // Set up control button event listeners
      playBtn.addEventListener('click', playMusic);
      pauseBtn.addEventListener('click', pauseMusic);
      rewindBtn.addEventListener('click', rewind);

      // Initial button state
      console.log('Initial page load: Setting default button state.');
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      rewindBtn.disabled = false;

      // Function to set up playback interval
      function setPlaybackInterval(callback, delay) {
        clearPlaybackInterval(); // Clean up existing interval and worker
        
        try {
          // Create a simple interval
          workerInterval = setInterval(() => {
            try {
              callback();
            } catch (error) {
              console.warn('[playbackInterval] Error in interval callback:', error);
              clearPlaybackInterval();
            }
          }, delay);
          
          // Use a simple number for interval tracking
          const intervalId = Date.now();
          activeIntervals.set(intervalId, true);
          playbackInterval = intervalId;
          
          return intervalId;
        } catch (e) {
          console.warn('[setPlaybackInterval] Error setting up interval:', e);
          clearPlaybackInterval();
          return null;
        }
      }

      // Update playMusic function
      async function playMusic() {
        console.log('[playMusic] Called. Current state:', currentPlayer?.state);
        
        try {
          setButtonLoading(playBtn, true);

          // Initialize audio context if needed - this is now safe because it's triggered by a user gesture
          if (!audioContext || audioContext.state === 'closed') {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }

          // Resume audio context if suspended
          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }

          // If we have currentMusicXml but no player, create one
          if (currentMusicXml && !currentPlayer) {
            // Get current instrument selection
            const instrumentSelector = document.getElementById('instrumentSelector');
            const selectedInstrumentId = instrumentSelector.value || '0'; // Default to piano if none selected
            
            // Initialize SoundFont and create player
            await initializeSoundFont(selectedInstrumentId, true);
            await createNewPlayer(currentMusicXml, selectedInstrumentId);
          }

          if (!currentPlayer || (isProcessing && !isLoadingSoundFont)) {
            console.log('[playMusic] Aborted (no player or processing).');
            return;
          }

          clearPlaybackInterval();

          // Stop any current sounds and clear audio buffers
          if (currentOutput) {
            try {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.clear === 'function') {
                await currentOutput.clear();
              }
            } catch (e) {
              console.warn('[playMusic] Error clearing audio:', e);
            }
          }

          playBtn.disabled = true;
          pauseBtn.disabled = false;
          rewindBtn.disabled = false;

          // Small delay to ensure audio buffers are cleared
          await new Promise(resolve => setTimeout(resolve, 50));

          if (currentPlayer.state === 2) {
            console.log('[playMusic] Resuming from paused state');
            await safePlayerStateChange('play');
          } else {
            console.log('[playMusic] Starting playback');
            if (typeof currentPlayer.seek === 'function') {
              await currentPlayer.seek(0);
            }
            await safePlayerStateChange('play');
          }

          // Set up interval with improved error handling
          setPlaybackInterval(() => {
            if (currentPlayer && currentPlayer.state === 1) {
              if (currentPlayer.currentTime >= currentPlayer.duration) {
                clearPlaybackInterval();
                safePlayerStateChange('stop');
                playBtn.disabled = false;
                pauseBtn.disabled = true;
                rewindBtn.disabled = false;
                console.log('[playMusic] Playback completed');
              }
            }
          }, 100);
          
          console.log('[playMusic] Play/Resume successful. New state:', currentPlayer?.state);
        } catch (error) {
          console.error('Error playing music:', error);
          clearPlaybackInterval();
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
        } finally {
          setButtonLoading(playBtn, false);
        }
      }

      // Update pauseMusic function
      async function pauseMusic() {
        console.log('[pauseMusic] Called. Current state:', currentPlayer?.state);
        if (!currentPlayer || currentPlayer.state !== 1) {
          console.log('[pauseMusic] Aborted (no player or not playing).');
          return;
        }

        try {
          setButtonLoading(pauseBtn, true);
          clearPlaybackInterval();

          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;

          await safePlayerStateChange('pause');
          console.log('[pauseMusic] Pause successful. New state:', currentPlayer?.state);
        } catch (error) {
          console.error('Error pausing music:', error);
          const isPlaying = currentPlayer.state === 1;
          playBtn.disabled = isPlaying;
          pauseBtn.disabled = !isPlaying;
          rewindBtn.disabled = false;
        } finally {
          setButtonLoading(pauseBtn, false);
        }
      }

      // Update rewind function
      async function rewind() {
        console.log('[rewind] Called. Current state:', currentPlayer?.state);
        if (!currentPlayer) {
          console.log('[rewind] Aborted (no player).');
          return;
        }

        setButtonLoading(rewindBtn, true);
        
        try {
          // Disable all controls during rewind
          playBtn.disabled = true;
          pauseBtn.disabled = true;
          rewindBtn.disabled = true;

          // Store current state
          const wasPlaying = currentPlayer.state === 1;
          
          // Clear any existing intervals first
          clearPlaybackInterval();

          // Stop all current sounds and clear audio buffers
          if (currentOutput) {
            try {
              if (typeof currentOutput.stopAllSounds === 'function') {
                await currentOutput.stopAllSounds();
              }
              if (typeof currentOutput.clear === 'function') {
                await currentOutput.clear();
              }
            } catch (e) {
              console.warn('[rewind] Error clearing audio:', e);
            }
          }

          // Call the player's rewind method
          try {
            await safePlayerStateChange('rewind');
            console.log('[rewind] Player rewind successful');
          } catch (e) {
            console.warn('[rewind] Error during player rewind:', e);
            
            // Fallback manual rewind
            await safePlayerStateChange('stop');
            
            // Clear audio buffers again after stop
            if (currentOutput) {
              try {
                if (typeof currentOutput.stopAllSounds === 'function') {
                  await currentOutput.stopAllSounds();
                }
                if (typeof currentOutput.clear === 'function') {
                  await currentOutput.clear();
                }
              } catch (e) {
                console.warn('[rewind] Error clearing audio during fallback:', e);
              }
            }

            // Small delay to ensure audio buffers are cleared
            await new Promise(resolve => setTimeout(resolve, 50));
            
            if (typeof currentPlayer.seek === 'function') {
              await currentPlayer.seek(0);
            }
            
            // Reset renderer state
            const renderer = currentPlayer.renderer;
            if (renderer) {
              if (typeof renderer.resetCursor === 'function') {
                await renderer.resetCursor();
              }
              if (typeof renderer.render === 'function') {
                await renderer.render();
              }
              if (typeof renderer.updateCursor === 'function') {
                await renderer.updateCursor(0);
              }
            }
          }

          // Scroll to beginning
          const firstSystem = document.querySelector('g.system');
          if (firstSystem) {
            firstSystem.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }

          // Reset button states
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;

          // Small delay before resuming playback if it was playing
          if (wasPlaying) {
            await new Promise(resolve => setTimeout(resolve, 50));
            await playMusic();
          }

          console.log('[rewind] Rewind completed successfully');
        } catch (error) {
          console.error('[rewind] Critical error:', error);
          
          // Emergency recovery
          try {
            await cleanupPlayer();
            if (currentMusicXml) {
              await createNewPlayer(currentMusicXml, currentInstrumentId);
            }
          } catch (e) {
            console.error('[rewind] Recovery failed:', e);
          }
          
          // Reset to safe state
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;
        } finally {
          setButtonLoading(rewindBtn, false);
        }
      }

      // Update instrument selection handler
      document.getElementById('instrumentSelector').addEventListener('change', async (event) => {
        const selectedInstrumentId = event.target.value;
        if (!selectedInstrumentId) return; // Skip if no instrument selected

        try {
          console.log('[instrumentSelector.onChange] Changing instrument to:', selectedInstrumentId);
          
          // Show loading states
          setInstrumentSelectorLoading(true);
          setButtonLoading(playBtn, true);
          
          // Disable all controls during instrument change
          playBtn.disabled = true;
          pauseBtn.disabled = true;
          rewindBtn.disabled = true;

          // Store current playback state
          const wasPlaying = currentPlayer && currentPlayer.state === 1;
          const currentTime = currentPlayer ? currentPlayer.currentTime : 0;

          // Clean up current state
          await cleanupPlayer();

          // Initialize new instrument
          await initializeSoundFont(selectedInstrumentId, true);
          
          // Create new player with stored MusicXML
          if (currentMusicXml) {
            const player = await createNewPlayer(currentMusicXml, selectedInstrumentId);
            
            // Restore playback position if needed
            if (currentTime > 0) {
              await player.seek(currentTime);
            }

            // Resume playback if it was playing
            if (wasPlaying) {
              await playMusic();
            }
          }
          
          // Reset button states after successful change
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;

          const feedback = document.getElementById('feedback');
          feedback.className = 'success';
          feedback.textContent = 'Instrument changed successfully!';
        } catch (error) {
          console.error('Error changing instrument:', error);
          
          // Clean up on error
          await cleanupPlayer();
          
          // Reset to default state
          playBtn.disabled = false;
          pauseBtn.disabled = true;
          rewindBtn.disabled = false;

          const feedback = document.getElementById('feedback');
          feedback.className = 'error';
          feedback.textContent = `Error changing instrument: ${error.message}`;
        } finally {
          // Hide loading states
          setInstrumentSelectorLoading(false);
          setButtonLoading(playBtn, false);
        }
      });

      // Add tempo, pitch, and frequency control handlers
      // ... existing code ...
    </script>
  </body>
</html>
